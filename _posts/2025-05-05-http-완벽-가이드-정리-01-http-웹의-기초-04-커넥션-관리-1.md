---
layout: post
title: "[HTTP 완벽 가이드 정리] 01. HTTP: 웹의 기초 - 04. 커넥션 관리 (1)"
date: 2025-05-05 18:50 +0900
description: 4장 커넥션 관리에서는 HTTP에서 관리하는 TCP 커넥션에 대한 일반적인 오해들과 잘못 작성된 규칙 및 동작 방식에 대해서 알아본다.
category:
  - BOOKS
  - 네트워크
tags:
  - HTTP
  - 네트워크
  - CS
  - HTTP 완벽 가이드
published: true
sitemap: false
---
---

# 📝 핵심 요약

| 주제                | 요약                                                                                                                                                                      |
| ----------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **TCP 커넥션**       | - 메시지의 손실 또는 손상 방지 및 순서 보장으로 안전하게 전달<br>- 데이터 스트림을 잘게 나눈 **세그먼트 단위로 IP 패킷**에 담겨 전송                                                                                      |
| **TCP 성능에 대한 고려** | TCP 성능 최적화를 위해 지연에 대한 이해 필요<br>1) `TCP 커넥션의 핸드셰이크 설정`<br>2) `혼잡 제어를 위한 TCP의 느린 시작(slow-start)`<br>3) `네이글(nagle) 알고리즘`<br>4) `확인응답 지연 알고리즘`<br>5) `TIME_WAIT 지연과 포트 고갈` |

<br>

---
<br>
## 1. TCP 커넥션

### 🔌 TCP의 기초 개념

- **TCP(Transmission Control Protocol)**는 인터넷에서 데이터를 신뢰성 있게 전송하기 위해 사용되는 **연결 지향적 전송 계층 프로토콜**
    
- 데이터를 **바이트 스트림(byte stream)** 형태로 처리하며, 송신 측과 수신 측 사이에 논리적인 연결을 먼저 설정한 후 통신을 시작
    
- TCP는 데이터를 **세그먼트(Segment)** 단위로 분할해 전송하고, 이 세그먼트는 IP 계층에서 **IP 패킷(Packet)**의 형태로 캡슐화되어 전달
    
#### ⚒️ TCP의 특징

| 특징         | 설명                                                                  |
| ---------- | ------------------------------------------------------------------- |
| **순서 보장**  | 전송된 데이터가 수신 측에 **정확한 순서로 도착**하도록 보장함                                |
| **신뢰성 확보** | **손상되거나 손실된 세그먼트를 재전송**하여 데이터의 정확성과 완전성을 보장함                        |
| **흐름 제어**  | 수신 측의 처리 능력에 맞춰 송신 속도를 조절하여 수신 버퍼의 오버플로우를 방지함                       |
| **혼잡 제어**  | 네트워크 상태를 고려해 전송량을 조절하여 혼잡을 방지 (예: slow start, congestion avoidance) |

<br><br>
### 🧱 HTTP/HTTPS의 네트워크 프로토콜 스택

#### 📄 HTTP 프로토콜 스택

```
-----------------
| 애플리케이션 계층 |  ─▶  HTTP
-----------------
| 전송 계층       |  ─▶  TCP
-----------------
| 네트워크 계층    |  ─▶  IP
-----------------
| 데이터 링크 계층  |  ─▶  Network Interfaces (Ethernet, Wi-Fi 등)
-----------------
```

#### 🔒 HTTPS 프로토콜 스택

```
-----------------
| 애플리케이션 계층 |  ─▶  HTTP
-----------------
| 보안 계층       |  ─▶  TLS or SSL
-----------------
| 전송 계층       |  ─▶  TCP
-----------------
| 네트워크 계층    |  ─▶  IP
-----------------
| 데이터 링크 계층  |  ─▶  Network Interfaces (Ethernet, Wi-Fi 등)
-----------------
```

> HTTP는 TCP 기반 위에서 동작하고, HTTPS는 여기에 TLS 계층을 추가하여 보안 기능(암호화, 무결성, 인증)을 제공함

<br><br>
### 🧩 TCP 연결 식별을 위한 4가지 요소

- 하나의 TCP 연결을 고유하게 식별하며, 이를 통해 다수의 연결을 동시에 관리할 수 있음

```
<발신자 IP 주소, 발신자 포트, 수신자 IP 주소, 수신자 포트>
```

> 서로 다른 두 개의 TCP 커넥션은 네 가지 주소 구성요소의 값이 모두 같을 수 없음

<br>

---
<br>
## 2**. TCP 성능에 대한 고려**

### ⏱️ 주요 지연 요인

-  HTTP 요청을 보내고 응답을 받을 때까지의 **전체 트랜잭션 시간**은 다양한 요소가 중첩되어 지연될 수 있음
	
- TCP 연결 설정, 패킷 왕복 시간, 서버 처리 시간, 응답 데이터 전송 시간 등이 합쳐져 **최종 지연을 유발**
	
| 지연 원인                   | 설명                                                                             |
| ----------------------- | ------------------------------------------------------------------------------ |
| **DNS 이름 분석**           | 도메인 이름을 IP 주소로 변환하는 과정으로,<br>**외부 DNS 서버와의 통신으로 인해 지연이 발생**할 수 있음              |
| **TCP 연결 설정 및 슬로우 스타트** | TCP **3-way handshake**로 발생하는 지연과<br>혼잡 제어 초기 단계에서 데이터 **전송 속도가 제한**되어 지연이 발생함 |
| **왕복 시간(RTT)**          | 요청-응답 간 패킷이 왕복하는 데 걸리는 시간으로,<br>**네트워크 거리 및 혼잡도에 따라 증가**함                      |
| **서버 리소스 접근 지연**        | 디스크 I/O, 데이터베이스 조회, 캐시 미스 등<br>**서버 내부 처리 과정에서 응답 지연이 발생**할 수 있음               |

<br><br>
### ❗️ TCP 성능 관련 요소

#### 🐢 TCP 커넥션 핸드셰이크 지연

```
TCP 3-way handshake 과정

-----------                   ---------
| 클라이언트 | ------ SYN ---->  | 서버   |
|         | <-- SYN + ACK --- |       |
|         | - ACK (+ 데이터) -> |       |
-----------                   ---------

1. 클라이언트 → 서버: SYN 플래그가 설정된 패킷을 보내 연결 요청 
2. 서버 → 클라이언트: SYN + ACK 플래그가 설정된 패킷으로 수락 응답
3. 클라이언트 → 서버: ACK 패킷으로 최종 확인 (이때 데이터 전송 가능)
```

- 최신 TCP 스택은 클라이언트가 **ACK 패킷에 HTTP 요청을 포함**할 수 있어 지연을 줄일 수 있음

> 문제점
> - 이 과정은 **최소 1 RTT(Round-Trip Time)** 이상이 소요되며,<br>특히 **작은 HTTP 요청을 자주 보내는 경우 전체 트랜잭션 시간의 50% 이상이 연결 설정에 사용될 수 있음**
>   
> - 작고 빠른 응답(HTML, 이미지, 304 Not Modified 등)에서는 전송 자체보다 연결 설정에 더 많은 시간이 소비될 수 있음
{: .prompt-warning}

> 이러한 지연을 줄이기 위해,<br>
> HTTP/1.1부터는 **지속 연결(persistent connection)** 기능을 기본 제공하여<br>**한 번 설정한 연결을 재사용**할 수 있게 됨
{: .prompt-tip}

<br>
#### 🐌 확인응답 지연

- TCP는 각 세그먼트 수신 시마다 **ACK(확인 응답)** 패킷을 송신자에게 반환
    
- 네트워크 효율을 높이기 위해, 일부 TCP 구현에서는 **확인응답 지연 알고리즘**을 사용

		1) 수신자는 일정 시간(보통 100~200ms) 동안 ACK를 지연시켰다가
		
		2) 같은 방향의 데이터 패킷이 있다면 그 패킷에 ACK를 함께 담아(piggybacking) 전송
		
		3) 이 시간 동안 송신할 데이터가 없다면 단독 ACK 패킷을 전송

> 문제점
> - 하지만 HTTP처럼 요청-응답이 분리된 구조에서는 **역방향 데이터 패킷이 거의 없어**,<br>piggybacking이 잘 일어나지 않고 확인응답 지연이 실제 성능 저하로 이어짐
{: .prompt-warning}

> 운영체제에 따라 지연 ACK 설정을 조정하거나 비활성화할 수 있지만,<br>TCP 알고리즘은 인터넷 전체의 안정성을 고려해 설계된 것이므로 조정 시 신중함이 필요
{: .prompt-tip}

<br>
#### 🐢 TCP의 느린 시작 (Slow Start)

- TCP는 새 연결이 시작되면 **처음부터 최대 속도로 데이터를 전송하지 않고**,<br>혼잡 방지를 위해 천천히 전송량을 증가시킴
    
- 전송이 성공하고 ACK를 받을 때마다 허용 가능한 전송량을 점진적으로 늘려감
    
    - 처음엔 1개 패킷 전송 → ACK 받으면 2개 전송 허용 → 그다음 4개, 8개, ... (지수적 증가)
      
- 이를 통해 **혼잡 윈도우(congestion window)**의 크기를 점진적으로 늘려가며,<br>초기 연결에서 갑작스러운 대량 데이터 전송으로 인한 네트워크 혼잡을 방지하고 안정적으로 전송 속도를 향상시킴

> 문제점
> - 요청/응답이 작은 경우에도 새로운 TCP 연결마다 Slow Start가 작동하므로 성능이 저하될 수 있음
>
> - 예를 들어 작은 HTML 문서나 이미지 요청 시, 데이터 전송 자체보다 Slow Start로 인한 지연이 더 클 수 있음
{: .prompt-warning}

> 이를 해결하기 위해 HTTP는 기존 연결을 재사용하는 **지속 연결(persistent connection)** 도입
> - 이미 튜닝된 연결을 재사용하면 초기 느린 속도를 회피할 수 있음
{: .prompt-tip}

<br>
#### 🐌 Nagle 알고리즘과 TCP_NODELAY

- TCP는 애플리케이션이 어떤 크기의 데이터든지 전송할 수 있도록 데이터 스트림 인터페이스를 제공
  
- 하지만, **작은 패킷이 지나치게 많아지면 네트워크 성능이 심각하게 저하**될 수 있음<br>(TCP 세그먼트는 40바이트 상당의 플래그와 헤더를 포함하고 있다)
    
- 이를 방지하기 위해, TCP는 **Nagle 알고리즘**을 사용하여 **작은 데이터를 모아서 하나의 패킷으로 전송**

		1) 세그먼트가 최대 크기가 되지 않으면 전송하지 않음
		
		2) 다른 모든 패킷이 확인응답을 받은 경우, 최대 크기가 되지 않아도 전송
		
		3) 다른 패킷들이 아직 전송 중이면 버퍼에 데이터 저장
		
		4) 확인응답을 기다리던 패킷이 확인응답을 받았거나 충분한 패킷이 쌓인 경우, 버퍼의 데이터가 전송

- 결과적으로 네트워크 상의 패킷 수를 줄여 혼잡을 방지하지만, **지연에 민감한 애플리케이션**에는 불리할 수 있음

> 문제점
> - 작은 HTTP 요청은 패킷 하나를 채우지 못하므로 **전송이 지연될 수 있고**,<br>확인응답 지연과 결합되면 **200ms 이상의 지연**이 발생할 수 있음
>   
> - 특히 pipelining 환경에서는 여러 요청이 순서대로 대기하고 있기 때문에,<br>**첫 번째 요청의 응답이 지연되면 이후 모든 요청의 응답도 함께 지연되는 Head-of-Line blocking 현상이 심화될 수 있음**
{: .prompt-warning}

> TCP_NODELAY로 해결
> - `TCP_NODELAY` 옵션을 설정하면 Nagle 알고리즘이 **비활성화되어 즉시 전송**
>
> - 실시간성이 중요한 애플리케이션에서는 성능 향상을 위해<br>**Nagle 알고리즘을 끄고 데이터를 즉시 전송**하는 방식을 고려해 볼 수 있음
> 
> 단, `TCP_NODELAY` 사용 시 작은 패킷이 너무 많이 발생하지 않도록<br>**애플리케이션에서 충분한 데이터 블록 단위로 전송하는 설계가 필요**
{: .prompt-tip}

<br>
#### 🐢 TIME_WAIT 누적과 포트 고갈

- TCP 연결이 종료되면, 해당 연결의 IP/포트 정보를 **2MSL (보통 약 2분)** 동안 보관하여 동일한 연결 정보로 새 연결이 생성되지 않도록 막음 (**TIME_WAIT 상태**로 유지됨)
    
- 이는 **이전 연결의 지연된 패킷이 새 연결에 잘못 섞이는 것을 방지**하기 위함
	
- 하지만 짧은 시간 내에 많은 연결을 반복적으로 생성하면 TIME_WAIT 소켓이 급격히 쌓이고,<br>결국 **포트 고갈**로 새로운 연결을 생성할 수 없는 상황이 발생
    
- 예로 **벤치마킹 또는 부하 테스트처럼 단일 IP와 포트를 집중적으로 사용하는 경우**,<br>사용 가능한 포트가 고갈되어 새로운 연결 생성이 차단될 수 있음

> 문제 예시
> 
> 1) 하나의 클라이언트와 하나의 서버가 통신할 때,<br>고정된 IP/포트를 사용하면 **발신지 포트만 바꿔서 연결을 구분**해야 함
>   
> 2) 사용 가능한 포트가 60,000개이고 2분간 재사용이 불가능하다면 → 최대 **500 TPS (초당 트랜잭션)**로 제한
>
> 3) 아무리 서버 성능을 높여도 연결 수가 제한되므로 테스트 결과가 왜곡될 수 있음
{: .prompt-warning}

> 해결 방안
> - 부하 생성기(클라이언트) 또는 서버의 **IP 주소를 다중화**하거나, **여러 대의 테스트 머신 사용** 
>   
> - 운영체제의 **2MSL 값을 조정**할 수도 있지만, 이는 패킷 중복 위험을 높일 수 있으므로 신중히 다뤄야 함
{: .prompt-tip}

> 포트 고갈을 겪지 않더라도 대기 상태로 있는 제어 블록이 너무 많아지는 상황은 주의
{: .prompt-info}
<br>

---
